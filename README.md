![putting the squid in squidwork](http://i.imgur.com/cqFMQIH.png)

# squidwork.
Simple JSON wrapper protocol for ZeroMQ.

## Why

I want to make it trivial to broadcast and consume events that happen
in the apartment. If you find a way to detect something in the apartment,
create a daemon that notifies the rest of us about it. 

Some examples of possible event publishers:

- IR reciever
- `bro` based network activity monitors
- voice recognition devices
- generic security sytems
- desktop apps
- web apps

Some examples of micro-daemons that we could do with these event publishers:

- Display events on the desktop using `notify-send` on Linux boxes, and Growl on OS X
- handle Wit.ai intents generated by the microphone on other systems
- automatically activate game mode when the TV is switched on

## Protocol: Pub-Sub Message Envelopes

http://zguide.zeromq.org/page:all#Pub-Sub-Message-Envelopes

We send two-part messages over the ZeroMQ sockets:

    PART1: (the origin)  STRING like 'myapp/user/login@host.name'
    PART2: (the message) JSON of format {
        'content': JSON,
        'time'   : STRING like '%Y-%m-%d %H:%M',
        'origin' : STRING like 'myapp/user/login@host.name'
    }

We send the message in two seperate parts to handle endpoint
subscriptions neatly: ZeroMQ manages subscriptions by checking
for byte equality between the subscription filters and every
inbound message. [More info][1].
Byte-string equality is easy on strings, and
hard on JSON coming from an unsorted hashmap ;)

we put the hostname origin at the end because who cares where
its coming from? only what the API startpoint is.

All wire bytes are UTF8-encoded string, and start with the
string 'all'.

[1]: http://api.zeromq.org/4-0:zmq-setsockopt#toc6

## module `squidwork.quick`

You can use `squidwork.quick.pub` and `squidwork.quick.sub` to
create the type of ZeroMQ socket you need to send or receive events,
and never have to import zmq yourself, or worry about the other
socket types. Here is a simple event publisher and a reciever:

```python
# event emitter
from squidwork.quick import pub
from squidwork import Sender
from time import sleep

endpoint = Sender(pub('tcp://127.0.0.1:6696'))
while True:
    sleep(3)
    endpoint.send(['hello', 'world'])
```

```python
# event listener
from squidwork.quick import pub
from squidwork import Sender

reciever = Reciever(sub('tcp://127.0.0.1:6696'))
while True:
    # this call blocks
    message = reciever.recieve()

    print message.origin
    print message.time
    print message.content
```

## module `squidwork.web`

This module provides an implementation of the protocol over Websockets
for Javascript clients. I'm only planning on implementing subscribing 
features, no publishing. Here's a somple example:

```html
<script type="text/javascript" src="http://squidwork.internal/squidwork.js"></script>
```
```coffeescript
# squidwork imported into `window` namespace already
sub = squidwork.subscribe 'tcp://192.168.0.1:9999', 'ear/active', (message) ->
    document.body.innerHTML = message.content

# re-assign sub.fn to change the handler
sub.fn = (message) ->
    console.log("Got message: ", message)

# we don't care anymore
sub.unsubscribe()
```

This is implemented on top of the Tornado event loop in python and ZeroMQ
streams. To run the bridge, execute the following:

```shell
python -m squidwork.web -c ./config.yml
```

If you direct your browser to `http://localhost:8888` you will see a mostly-blank
page that directs you to open your eveloper console. From there you can inspect
the configuration data and create new subscriptions!

## module `squidwork.web.monitor`

At this point, we've got a full blown web micro-library going on in 
`squidwork.web.handlers`, and a pretty great Javascript squidwork API, so why
not make a real front-end app of equal quality?

The **monitor** is a graphical log of recent squidwork messages.
depending on configuration, it displays a list of the last N squidwork events.
It can filter for uniqueness (squashing a bunch of duplicates), or just display
things chronologically.

monitor requires several extra packages to support its beautiy:
    - pyScss to render stylesheets

I feel like I might be pioneering strange application architectures at this
point. Here's what we've got so far:

- ZeroMQ pub-sub data source
- data becomes JSON
  - some is stream over WebSockets to front-end
  - some is plain-jain JSON
- tornado webserver to deliver templates and websockets
  - templates mostly static, only dynamic so we can ship over config values
  - *only 4 lines of HTML*
- coffeescript front-end app consumer
- views rendered on the client by [Mithril.js][mithril]

I can't tell if Mithril.js is awesome or what. Look at the 
[occlusion culling][oc] bit the creator does: we've got a full data binding
application (or at least view-controller) in 43 lines. So refreshing compared
to Ember.js.

[mithril]: http://lhorie.github.io/mithril/index.html
[oc]: http://lhorie.github.io/mithril-blog/an-exercise-in-awesomeness.html#occlusion-culling

The worst part is that I can't tell if what's genius, or Don Music.
(That was a Sesame Street reference).

## Service definitions

squidwork also provides a main-entrypoint framework for loading
service definitions from a YAML file, so that we can define in
one place an apartment-wide list of ZeroMQ publishers. Now,
we could just use broadcast services to do anounces but we're 
an apartment so like a ten-line file synced with git is much easier.

We also support reading the file from an HTTP server (although this 
is so far untested).

## Working with the code

### Requirements

1. pyzmq
2. pyyaml  (for config)
3. tornado (for squidwork.websocket, which depends on config)

### Integration Tests

The tests in `tests/` come in pairs, one sender and one receiver for each
strategy.
